#!/usr/bin/env node
const fs = require('fs')
const path = require('path')
const vm = require('vm')

const filePath = path.join(__dirname, '../lib/i18n/translations.js')
const outPath = filePath

const src = fs.readFileSync(filePath, 'utf8')

const marker = '// Build translations object from translation keys'
const markerIdx = src.indexOf(marker)
if (markerIdx === -1) {
  console.error('Marker not found in translations.js')
  process.exit(1)
}

// Extract the portion that defines `languages` and `t` (from start until marker)
const head = src.slice(0, markerIdx)

// Find start of `const t =` inside head
const tStartIdx = head.indexOf('const t =')
if (tStartIdx === -1) {
  console.error('Could not find "const t =" in file')
  process.exit(1)
}

// We'll evaluate the t object by extracting from "const t =" up to the end of that object.
const afterT = head.slice(tStartIdx)

// Find the end of the object by locating the closing `}` that ends the top-level t object.
// Count braces while respecting simple string escapes to avoid miscounting braces inside strings.
function findObjectEnd(s) {
  let i = s.indexOf('{')
  if (i === -1) return -1
  let depth = 0
  let inSingle = false
  let inDouble = false
  let inBacktick = false
  for (let p = i; p < s.length; p++) {
    const ch = s[p]
    const prev = s[p - 1]
    if (!inSingle && !inDouble && !inBacktick) {
      if (ch === "'") inSingle = true
      else if (ch === '"') inDouble = true
      else if (ch === '`') inBacktick = true
    } else {
      if (ch === "'" && inSingle && prev !== '\\') inSingle = false
      if (ch === '"' && inDouble && prev !== '\\') inDouble = false
      if (ch === '`' && inBacktick && prev !== '\\') inBacktick = false
      // when inside a string, skip brace counting
      if (inSingle || inDouble || inBacktick) continue
    }
    if (ch === '{') depth++
    else if (ch === '}') {
      depth--
      if (depth === 0) return p
    }
  }
  return -1
}

const objEndRel = findObjectEnd(afterT)
if (objEndRel === -1) {
  console.error('Could not find end of t object')
  process.exit(1)
}

const tSource = afterT.slice(0, objEndRel + 1)

// Evaluate the t object safely
let tObj
try {
  tObj = vm.runInNewContext('(function(){\n' + tSource + '\n return t;\n})()')
} catch (err) {
  console.error('Failed to evaluate t object:', err)
  process.exit(1)
}

// Rebuild a cleaned t object preserving the final values for each key (no duplicates left)
const cleanedT = {}
Object.keys(tObj).forEach((k) => {
  cleanedT[k] = tObj[k]
})

// Extract languages definition from head (assume it appears before const t)
const languagesMatch = head.slice(0, tStartIdx).match(/export const languages = \[([\s\S]*?)\];/)
let languagesSource = ''
if (languagesMatch) {
  languagesSource = 'export const languages = [' + languagesMatch[1] + '];\n\n'
} else {
  console.warn('languages array not found; using fallback minimal list')
  languagesSource = "export const languages = [{ code: 'en', name: 'English', flag: 'ðŸ‡¬ðŸ‡§' }];\n\n"
}

// Compose new file content: header comment + languages + cleaned t + buildTranslations + exports
const newContent = `// Cleaned translations file (duplicates removed)\n// Generated by scripts/clean-translations.js\n\n${languagesSource}const t = ${JSON.stringify(cleanedT, null, 2)}\n\n${marker}\nconst buildTranslations = () => {\n  const result = {}\n  languages.forEach((lang) => {\n    result[lang.code] = {}\n    Object.keys(t).forEach((key) => {\n      result[lang.code][key] = t[key][lang.code] || t[key].en\n    })\n  })\n  return result\n}\n\nexport const translations = buildTranslations()\n\nexport default { translations, languages }\n`

fs.writeFileSync(outPath, newContent, 'utf8')
console.log('translations.js cleaned and overwritten')
